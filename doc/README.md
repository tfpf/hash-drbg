# Technical Information
| Property               | Value    |
| :--------------------: | :------: |
| Security Strength      | 256 bits |
| Hash                   | SHA-256  |
| Prediction Resistance  | Yes      |
| Additional Input       | No       |
| Personalisation String | No       |

* SHA-256 has been implemented from scratch, because I wanted this package to have no dependencies.
* `/dev/urandom` is read to obtain entropy for seeding and reseeding.
  * It is assumed to always provide sufficient entropy.
* Nonces are generated by appending a monotonically increasing sequence number to the timestamp.
  * If the compiler supports standard atomics, the sequence number is an atomic integer—whence, in a process with
    multiple threads, no two threads will generate the same nonce.
  * Otherwise, two threads might end up with the same nonce because of a data race. (Two threads in different processes
    which load the library at the same time will also generate the same nonce, because the sequence number is
    initialised to 0.) Which shouldn't be a problem, because their entropy inputs will be different with high
    probability.
* In C, a byte need not be 8 bits wide. However, this implementation uses the term 'byte' to refer to an 8-bit number.
  Hence, fixed-width integer types are used liberally.

# Types
```C
struct hdrbg_t;
```
The type of an HDRBG object. It is implemented as an opaque struct.

---

```C
enum hdrbg_err_t;
```
The type of the error indicator. It can take the following values.
* `HDRBG_ERR_NONE` No error.
* `HDRBG_ERR_OUT_OF_MEMORY` Dynamic memory allocation failed.
* `HDRBG_ERR_NO_ENTROPY` No entropy could be obtained from `/dev/urandom`.
* `HDRBG_ERR_INSUFFICIENT_ENTROPY` Insufficient entropy was obtained from `/dev/urandom`.
* `HDRBG_ERR_INVALID_REQUEST` The `r_length` argument of a call to `hdrbg_fill` was greater than 65536.

# Functions
```C
enum hdrbg_err_t hdrbg_err_get(void);
```
Obtain the error indicator (which is a global variable similar to `errno`, but cannot be accessed directly). If the
compiler supports standard threads, a separate error indicator is maintained for each thread.

Calling this function clears the error indicator. For instance, if it is called twice in succession, the first call
may return `HDRBG_ERR_OUT_OF_MEMORY`, but the second call will return `HDRBG_ERR_NONE`.

In theory, each of the below functions can error out, so a call to each of them should be followed by a call to this
function to check for errors. Any error (other than `HDRBG_ERR_INVALID_REQUEST`) leaves the pseudorandom number
generator in an intermediate state, making it cryptographically insecure for further use.

In practice, on a modern system with loads of memory, `HDRBG_ERR_INVALID_REQUEST` is the only error which you can
realistically expect.

* → Error indicator.

---

```C
struct hdrbg_t *hdrbg_init(bool dma);
```
Create and/or initialise (seed) an HDRBG object.
* `dma` Whether to use dynamic memory allocation. If `true`, an HDRBG object will be allocated dynamically and
  initialised. If `false`, the internal HDRBG object will be initialised.
* →
  * On success:
    * if `dma` is `true`: initialised HDRBG object (which must be destroyed using `hdrbg_zero` to avoid memory leaks).
    * if `dma` is `false`: `NULL`.
  * On failure: `NULL`.

---

```C
struct hdrbg_t *hdrbg_reinit(struct hdrbg_t *hd);
```
Reinitialise (reseed) an HDRBG object. If it had not been previously initialised, the behaviour is undefined.
* `hd` HDRBG object to reinitialise. If `NULL`, the internal HDRBG object will be reinitialised.
* → `hd`.

---

```C
size_t hdrbg_fill(struct hdrbg_t *hd, bool prediction_resistance, uint8_t *r_bytes, size_t r_length);
```
Generate cryptographically secure pseudorandom bytes using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* `prediction_resistance` Whether prediction resistance is desired (i.e. whether the HDRBG object should be
  reinitialised before generating the bytes). Prediction resistance makes the next state of `hd` unpredictable even if
  its current state were to somehow become known.
* `r_bytes` Array to store the generated bytes in. (It must have sufficient space for `r_length` elements.)
* `r_length` Number of bytes to generate. At most 65536.
* → Number of bytes generated.

---

```C
uint64_t hdrbg_rand(struct hdrbg_t *hd);
```
Generate a cryptographically secure pseudorandom number using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined. This function internally uses `hdrbg_fill` without prediction
resistance.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* → Uniform pseudorandom integer in the range 0 (inclusive) to 2<sup>64</sup> − 1 (inclusive).

---

```C
uint64_t hdrbg_uint(struct hdrbg_t *hd, uint64_t modulus);
```
Generate a cryptographically secure pseudorandom residue using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined. This function internally uses `hdrbg_rand`.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* `modulus` Positive integer.
* → Uniform pseudorandom integer in the range 0 (inclusive) to `modulus` (exclusive).

---

```C
int64_t hdrbg_span(struct hdrbg_t *hd, int64_t left, int64_t right);
```
Generate a cryptographically secure pseudorandom residue offset using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined. This function internally uses `hdrbg_uint`.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* `left` Left end of the interval.
* `right` Right end of the interval. Must be greater than `left`.
* → Uniform pseudorandom integer in the range `left` (inclusive) to `right` (exclusive).

---

```C
double long hdrbg_real(struct hdrbg_t *hd);
```
Generate a cryptographically secure pseudorandom fraction using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined. This function internally uses `hdrbg_rand`.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* → Uniform pseudorandom real in the range 0 (inclusive) to 1 (inclusive).

---

```C
void hdrbg_zero(struct hdrbg_t *hd);
```
Zero (clear) and/or destroy an HDRBG object.
* `hd` HDRBG object to zero and destroy. If `NULL`, the internal HDRBG object will be zeroed.

---

```C
void hdrbg_dump(uint8_t const *m_bytes, size_t m_length);
```
Display the given data in hexadecimal form.
* `m_bytes` Array of bytes representing the big-endian data to display.
* `m_length` Number of bytes to display.
