# Technical Information
| Property               | Value    |
| :--------------------: | :------: |
| Security Strength      | 256 bits |
| Hash                   | SHA-256  |
| Prediction Resistance  | Yes      |
| Additional Input       | No       |
| Personalisation String | No       |

* SHA-256 has been implemented from scratch, because I wanted this package to have no dependencies.
* `/dev/urandom` is read to obtain entropy for seeding and reseeding.
  * It is assumed to always provide sufficient entropy.
* Nonces are generating by appending a monotonically increasing sequence number to the timestamp.
  * If the compiler supports atomics (GCC and Clang do), the sequence number is an atomic integer—whence, unique nonces
    will be generated even in a program with multiple threads.
  * Otherwise, two threads might end up with the same nonce because of a data race. (Two processes which load the
    library at the same time might also produce the same nonce, because the sequence number is initialised to 0.) Which
    shouldn't be a problem, because their entropy inputs will be different with high probability.
* In C, a byte need not be 8 bits wide. However, this implementation uses the term 'byte' to refer to an 8-bit number.
  Hence, fixed-width integer types are used liberally.

# Functions
```C
struct hdrbg_t *hdrbg_new(bool dma);
```
Create and/or initialise (seed) an HDRBG object.
* `dma` Whether to use dynamic memory allocation. If `true`, an HDRBG object will be allocated dynamically and
  initialised. If `false`, the internal HDRBG object will be initialised.
* → Initialised HDRBG object (which must be destroyed using `hdrbg_delete` to avoid memory leaks) if `dma` is `true`,
  else `NULL`.

---

```C
void hdrbg_renew(struct hdrbg_t *hd);
```
Reinitialise (reseed) an HDRBG object. If it had not been previously initialised, the behaviour is undefined.
* `hd` HDRBG object to reinitialise. If `NULL`, the internal HDRBG object will be reinitialised.

---

```C
bool hdrbg_gen(struct hdrbg_t *hd, bool prediction_resistance, uint8_t *r_bytes, size_t r_length);
```
Generate cryptographically secure pseudorandom bytes using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* `prediction_resistance` Whether prediction resistance is desired (i.e. whether the HDRBG object should be
  reinitialised before generating the bytes). Prediction resistance makes the next state of `hd` unpredictable even if
  its current state were to somehow become known.
* `r_bytes` Array to store the generated bytes in. (It must have sufficient space for `r_length` elements.)
* `r_length` Number of bytes to generate. At most 65536.
* → `true` if `r_length` is less than or equal to 65536, else `false`. In the latter case, the contents of `r_bytes`
  are not changed.

---

```C
uint64_t hdrbg_rand(struct hdrbg_t *hd);
```
Generate a cryptographically secure pseudorandom number using an HDRBG object. If it had not been previously
initialised/reinitialised, the behaviour is undefined. This function simply generates 8 bytes using `hdrbg_gen` without
prediction resistance.
* `hd` HDRBG object to use. If `NULL`, the internal HDRBG object will be used.
* → Uniform pseudorandom 64-bit number.

---

```C
void hdrbg_delete(struct hdrbg_t *hd);
```
Clear (zero) and/or destroy an HDRBG object.
* `hd` HDRBG object to clear and destroy. If `NULL`, the internal HDRBG object will be cleared.
